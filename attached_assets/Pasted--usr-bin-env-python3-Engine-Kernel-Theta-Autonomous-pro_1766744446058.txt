#!/usr/bin/env python3
"""
Engine Kernel Theta - Autonomous, production-oriented single-file kernel module
- No Flask, no simulation placeholders, no demo runs
- Durable SQLite-backed persistence and queue
- Realistic, pluggable PaymentGateway interface with a local ledger implementation
- Threaded worker pool for real execution
- Admin with PBKDF2 password hashing
- Operator management, selection, and accounting
- Revenue booking, owner payouts, reconciliation, withdrawals
- Idempotent operations and transactional safety via SQLite
- Logging and simple CLI control (start/stop/status)
USAGE:
  - Save as engine_kernel_theta.py
  - Run: python engine_kernel_theta.py
  - The kernel starts and listens for CLI commands on stdin (type 'help' for commands)
NOTE:
  - This is a self-contained kernel suitable for local/edge deployment.
  - Integrate real external payment processors by implementing PaymentGateway interface.
"""

import os
import sys
import time
import uuid
import json
import hmac
import hashlib
import threading
import sqlite3
import logging
from dataclasses import dataclass, asdict
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Callable

# -------------------------
# Logging
# -------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(threadName)s %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger("EngineKernelTheta")

# -------------------------
# Enums & Dataclasses
# -------------------------
class ProblemStatus(str, Enum):
    CREATED = "CREATED"
    PRICED = "PRICED"
    PAYMENT_PENDING = "PAYMENT_PENDING"
    PAYMENT_CONFIRMED = "PAYMENT_CONFIRMED"
    EXECUTING = "EXECUTING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"

class PayoutStatus(str, Enum):
    EARNED = "EARNED"
    READY = "READY"
    DONE = "DONE"

class WithdrawalStatus(str, Enum):
    REQUESTED = "REQUESTED"
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"

@dataclass
class Operator:
    id: str
    name: str
    capabilities: str  # comma-separated
    factor: float
    active: int  # 1 or 0
    last_assigned: float

# -------------------------
# Utilities: Password Hashing (PBKDF2)
# -------------------------
def pbkdf2_hash(password: str, salt: Optional[bytes] = None, iterations: int = 200_000) -> Tuple[str, str]:
    if salt is None:
        salt = os.urandom(16)
    dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, iterations)
    return dk.hex(), salt.hex()

def pbkdf2_verify(password: str, hex_hash: str, hex_salt: str, iterations: int = 200_000) -> bool:
    salt = bytes.fromhex(hex_salt)
    dk = hashlib.pbkdf2_hmac("sha256", password.encode("utf-8"), salt, iterations)
    return hmac.compare_digest(dk.hex(), hex_hash)

# -------------------------
# Payment Gateway Interface & Local Ledger Implementation
# -------------------------
class PaymentGateway:
    """
    Implement this interface to integrate a real payment processor.
    Methods must be idempotent and durable.
    """
    def create_intent(self, intent_id: str, amount: float, currency: str, metadata: Dict[str, Any]) -> Dict[str, Any]:
        raise NotImplementedError

    def confirm_intent(self, intent_id: str) -> Dict[str, Any]:
        raise NotImplementedError

class LocalLedgerGateway(PaymentGateway):
    """
    Local durable ledger stored in SQLite (same DB) - deterministic, auditable.
    Suitable for autonomous kernel mode where external processors are not desired.
    """
    def __init__(self, db_path: str):
        self.db_path = db_path
        # ledger table is created by EngineKernel
    def create_intent(self, intent_id: str, amount: float, currency: str, metadata: Dict[str, Any]) -> Dict[str, Any]:
        # idempotent: if exists, return existing
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT id, amount, currency, status FROM payment_intents WHERE id = ?", (intent_id,))
            row = cur.fetchone()
            if row:
                return {"id": row[0], "amount": row[1], "currency": row[2], "status": row[3]}
            cur.execute(
                "INSERT INTO payment_intents (id, amount, currency, status, metadata, created_at) VALUES (?, ?, ?, ?, ?, ?)",
                (intent_id, amount, currency, "PENDING", json.dumps(metadata), int(time.time()))
            )
            conn.commit()
            return {"id": intent_id, "amount": amount, "currency": currency, "status": "PENDING"}
        finally:
            conn.close()

    def confirm_intent(self, intent_id: str) -> Dict[str, Any]:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT status FROM payment_intents WHERE id = ?", (intent_id,))
            row = cur.fetchone()
            if not row:
                raise ValueError("Intent not found")
            if row[0] == "CONFIRMED":
                return {"id": intent_id, "status": "CONFIRMED"}
            cur.execute("UPDATE payment_intents SET status = ?, confirmed_at = ? WHERE id = ?", ("CONFIRMED", int(time.time()), intent_id))
            conn.commit()
            return {"id": intent_id, "status": "CONFIRMED"}
        finally:
            conn.close()

# -------------------------
# Engine Kernel
# -------------------------
class EngineKernel:
    DB_FILE = "engine_kernel_theta.db"

    def __init__(self, worker_count: int = 2):
        self.db_path = os.path.abspath(self.DB_FILE)
        self._lock = threading.RLock()
        self._stop_event = threading.Event()
        self.worker_count = max(1, worker_count)
        self.workers: List[threading.Thread] = []
        self.queue_cv = threading.Condition()
        self._init_db()
        self.gateway = LocalLedgerGateway(self.db_path)
        self._start_workers()
        logger.info("EngineKernel initialized and workers started")

    # -------------------------
    # Database Schema & Helpers
    # -------------------------
    def _init_db(self):
        created = not os.path.exists(self.db_path)
        conn = sqlite3.connect(self.db_path, timeout=30, isolation_level=None)
        try:
            cur = conn.cursor()
            # Use WAL for concurrency
            cur.execute("PRAGMA journal_mode=WAL;")
            # problems
            cur.execute("""
            CREATE TABLE IF NOT EXISTS problems (
                id TEXT PRIMARY KEY,
                type TEXT NOT NULL,
                payload TEXT NOT NULL,
                status TEXT NOT NULL,
                price REAL NOT NULL,
                result TEXT,
                error TEXT,
                created_at INTEGER,
                updated_at INTEGER
            )""")
            # payment intents (kernel-level)
            cur.execute("""
            CREATE TABLE IF NOT EXISTS payment_intents (
                id TEXT PRIMARY KEY,
                problem_id TEXT,
                amount REAL,
                currency TEXT,
                status TEXT,
                metadata TEXT,
                created_at INTEGER,
                confirmed_at INTEGER
            )""")
            # revenues
            cur.execute("""
            CREATE TABLE IF NOT EXISTS revenues (
                id TEXT PRIMARY KEY,
                problem_id TEXT,
                amount REAL,
                currency TEXT,
                created_at INTEGER
            )""")
            # payouts
            cur.execute("""
            CREATE TABLE IF NOT EXISTS payouts (
                id TEXT PRIMARY KEY,
                problem_id TEXT,
                amount REAL,
                currency TEXT,
                status TEXT,
                created_at INTEGER,
                updated_at INTEGER
            )""")
            # pool (single row)
            cur.execute("""
            CREATE TABLE IF NOT EXISTS owner_pool (
                id INTEGER PRIMARY KEY CHECK (id = 1),
                balance REAL,
                currency TEXT,
                updated_at INTEGER
            )""")
            # withdrawals
            cur.execute("""
            CREATE TABLE IF NOT EXISTS withdrawals (
                id TEXT PRIMARY KEY,
                amount REAL,
                currency TEXT,
                method TEXT,
                note TEXT,
                status TEXT,
                created_at INTEGER,
                updated_at INTEGER
            )""")
            # operators
            cur.execute("""
            CREATE TABLE IF NOT EXISTS operators (
                id TEXT PRIMARY KEY,
                name TEXT,
                capabilities TEXT,
                factor REAL,
                active INTEGER,
                last_assigned REAL
            )""")
            # admin
            cur.execute("""
            CREATE TABLE IF NOT EXISTS admin (
                username TEXT PRIMARY KEY,
                password_hash TEXT,
                salt TEXT
            )""")
            # queue table for durable queue
            cur.execute("""
            CREATE TABLE IF NOT EXISTS work_queue (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                problem_id TEXT,
                enqueued_at INTEGER,
                locked INTEGER DEFAULT 0
            )""")
            # initialize pool row if missing
            cur.execute("INSERT OR IGNORE INTO owner_pool (id, balance, currency, updated_at) VALUES (1, 0.0, 'EUR', ?)", (int(time.time()),))
            # initialize default admin if missing
            cur.execute("SELECT COUNT(*) FROM admin")
            if cur.fetchone()[0] == 0:
                h, s = pbkdf2_hash("admin")
                cur.execute("INSERT INTO admin (username, password_hash, salt) VALUES (?, ?, ?)", ("admin", h, s))
            conn.commit()
        finally:
            conn.close()
        if created:
            logger.info("Database created at %s", self.db_path)

    # -------------------------
    # Admin Management
    # -------------------------
    def admin_verify(self, username: str, password: str) -> bool:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT password_hash, salt FROM admin WHERE username = ?", (username,))
            row = cur.fetchone()
            if not row:
                return False
            return pbkdf2_verify(password, row[0], row[1])
        finally:
            conn.close()

    def admin_change_password(self, username: str, old_password: str, new_password: str) -> bool:
        if not self.admin_verify(username, old_password):
            return False
        h, s = pbkdf2_hash(new_password)
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("UPDATE admin SET password_hash = ?, salt = ? WHERE username = ?", (h, s, username))
            conn.commit()
            logger.info("Admin password changed for %s", username)
            return True
        finally:
            conn.close()

    # -------------------------
    # Operator Management
    # -------------------------
    def add_operator(self, name: str, capabilities: List[str], factor: float = 1.0, active: bool = True) -> Operator:
        op = Operator(id=str(uuid.uuid4()), name=name, capabilities=",".join(capabilities), factor=factor, active=1 if active else 0, last_assigned=0.0)
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("INSERT INTO operators (id, name, capabilities, factor, active, last_assigned) VALUES (?, ?, ?, ?, ?, ?)",
                        (op.id, op.name, op.capabilities, op.factor, op.active, op.last_assigned))
            conn.commit()
            logger.info("Operator added: %s (%s)", op.name, op.id)
            return op
        finally:
            conn.close()

    def list_operators(self) -> List[Operator]:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT id, name, capabilities, factor, active, last_assigned FROM operators")
            rows = cur.fetchall()
            return [Operator(*row) for row in rows]
        finally:
            conn.close()

    def _select_operator(self, problem_type: str) -> Optional[Operator]:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            # prefer operators with capability and active, order by last_assigned asc
            cur.execute("""
                SELECT id, name, capabilities, factor, active, last_assigned
                FROM operators
                WHERE active = 1 AND (capabilities LIKE ? OR capabilities LIKE ? OR capabilities LIKE ? OR capabilities = '')
                ORDER BY last_assigned ASC
                LIMIT 1
            """, (f"{problem_type},%", f"%,{problem_type},%", f"%,{problem_type}"))
            row = cur.fetchone()
            if not row:
                # fallback to any active operator
                cur.execute("SELECT id, name, capabilities, factor, active, last_assigned FROM operators WHERE active = 1 ORDER BY last_assigned ASC LIMIT 1")
                row = cur.fetchone()
            if not row:
                return None
            op = Operator(*row)
            # update last_assigned
            cur.execute("UPDATE operators SET last_assigned = ? WHERE id = ?", (time.time(), op.id))
            conn.commit()
            return op
        finally:
            conn.close()

    # -------------------------
    # Pricing Formula (deterministic, production-ready)
    # -------------------------
    def price_for(self, problem_type: str, payload: Dict[str, Any]) -> float:
        base = 3.0
        length_factor = 0.0
        complexity_factor = 0.0
        if problem_type == "text_analysis":
            text = str(payload.get("text", ""))
            length = len(text)
            length_factor = (length / 200.0) * 1.0
            # complexity: ratio of punctuation and uppercase
            punct = sum(1 for c in text if c in ".,;:!?")
            upper = sum(1 for c in text if c.isupper())
            complexity = (punct + upper) / max(1, length)
            complexity_factor = complexity * 1.0
        elif problem_type == "numeric_analysis":
            nums = payload.get("numbers", [])
            length = len(nums)
            length_factor = (length / 100.0) * 0.5
            complexity = len([n for n in nums if isinstance(n, (int, float)) and n < 0]) / max(1, length) if length else 0.0
            complexity_factor = complexity * 0.5
        # operator factor average
        ops = self.list_operators()
        op_factor = sum(op.factor for op in ops) / max(1, len(ops))
        price = base + length_factor + (complexity_factor * op_factor * 0.5)
        price = max(1.0, round(price, 2))
        return price

    # -------------------------
    # Problem Intake & Durable Queue
    # -------------------------
    def submit_problem(self, problem_type: str, payload: Dict[str, Any]) -> str:
        pid = str(uuid.uuid4())
        now_ts = int(time.time())
        price = self.price_for(problem_type, payload)
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("INSERT INTO problems (id, type, payload, status, price, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                        (pid, problem_type, json.dumps(payload, ensure_ascii=False), ProblemStatus.PRICED.value, price, now_ts, now_ts))
            # create payment intent via gateway (idempotent)
            intent_id = str(uuid.uuid4())
            metadata = {"problem_id": pid}
            self.gateway.create_intent(intent_id, price, "EUR", metadata)
            # store kernel-level intent linking
            cur.execute("INSERT INTO payment_intents (id, problem_id, amount, currency, status, metadata, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                        (intent_id, pid, price, "EUR", "PENDING", json.dumps(metadata, ensure_ascii=False), now_ts))
            # enqueue durable work
            cur.execute("INSERT INTO work_queue (problem_id, enqueued_at, locked) VALUES (?, ?, 0)", (pid, now_ts))
            conn.commit()
            logger.info("Problem submitted %s price=%.2f intent=%s", pid, price, intent_id)
            return pid
        finally:
            conn.close()

    def list_pending_queue(self, limit: int = 50) -> List[str]:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT problem_id FROM work_queue WHERE locked = 0 ORDER BY enqueued_at ASC LIMIT ?", (limit,))
            return [r[0] for r in cur.fetchall()]
        finally:
            conn.close()

    # -------------------------
    # Payment Confirmation (idempotent)
    # -------------------------
    def confirm_payment(self, intent_id: str) -> bool:
        # confirm via gateway (idempotent)
        try:
            res = self.gateway.confirm_intent(intent_id)
        except Exception as e:
            logger.error("Payment gateway confirm failed: %s", e)
            return False
        if res.get("status") != "CONFIRMED":
            logger.error("Payment not confirmed for intent %s", intent_id)
            return False
        # mark kernel intent and problem status
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT problem_id, status FROM payment_intents WHERE id = ?", (intent_id,))
            row = cur.fetchone()
            if not row:
                logger.error("Intent %s not found in kernel", intent_id)
                return False
            problem_id = row[0]
            cur.execute("UPDATE payment_intents SET status = ?, confirmed_at = ? WHERE id = ?", ("CONFIRMED", int(time.time()), intent_id))
            cur.execute("UPDATE problems SET status = ?, updated_at = ? WHERE id = ?", (ProblemStatus.PAYMENT_CONFIRMED.value, int(time.time()), problem_id))
            conn.commit()
            logger.info("Payment confirmed for intent %s -> problem %s", intent_id, problem_id)
            return True
        finally:
            conn.close()

    # -------------------------
    # Worker Loop & Execution (real, deterministic)
    # -------------------------
    def _start_workers(self):
        for i in range(self.worker_count):
            t = threading.Thread(target=self._worker_loop, name=f"kernel-worker-{i+1}", daemon=True)
            self.workers.append(t)
            t.start()

    def _worker_loop(self):
        while not self._stop_event.is_set():
            pid = self._dequeue_next()
            if not pid:
                time.sleep(0.2)
                continue
            try:
                self._process_problem(pid)
            except Exception as e:
                logger.exception("Error processing problem %s: %s", pid, e)

    def _dequeue_next(self) -> Optional[str]:
        conn = sqlite3.connect(self.db_path, timeout=30)
        try:
            cur = conn.cursor()
            # find next unlocked item and lock it atomically
            cur.execute("BEGIN IMMEDIATE")
            cur.execute("SELECT id, problem_id FROM work_queue WHERE locked = 0 ORDER BY enqueued_at ASC LIMIT 1")
            row = cur.fetchone()
            if not row:
                conn.commit()
                return None
            qid, pid = row
            cur.execute("UPDATE work_queue SET locked = 1 WHERE id = ?", (qid,))
            conn.commit()
            return pid
        except sqlite3.OperationalError:
            # contention; return None to retry
            return None
        finally:
            conn.close()

    def _process_problem(self, pid: str):
        # load problem
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT id, type, payload, status, price FROM problems WHERE id = ?", (pid,))
            row = cur.fetchone()
            if not row:
                logger.warning("Problem %s not found", pid)
                return
            _, ptype, payload_json, status, price = row
            if status not in (ProblemStatus.PAYMENT_CONFIRMED.value, ProblemStatus.PRICED.value):
                logger.info("Skipping problem %s with status %s", pid, status)
                return
            # ensure payment confirmed before execution
            cur.execute("SELECT status FROM payment_intents WHERE problem_id = ?", (pid,))
            intent_row = cur.fetchone()
            if not intent_row or intent_row[0] != "CONFIRMED":
                logger.info("Problem %s payment not confirmed yet", pid)
                # unlock queue entry for later retry: mark locked=0
                cur.execute("UPDATE work_queue SET locked = 0 WHERE problem_id = ?", (pid,))
                conn.commit()
                return
            # set executing
            cur.execute("UPDATE problems SET status = ?, updated_at = ? WHERE id = ?", (ProblemStatus.EXECUTING.value, int(time.time()), pid))
            conn.commit()
        finally:
            conn.close()

        # select operator
        op = self._select_operator(ptype)
        if not op:
            # mark failed
            conn = sqlite3.connect(self.db_path)
            try:
                cur = conn.cursor()
                cur.execute("UPDATE problems SET status = ?, error = ?, updated_at = ? WHERE id = ?",
                            (ProblemStatus.FAILED.value, "no operator available", int(time.time()), pid))
                conn.commit()
            finally:
                conn.close()
            logger.error("No operator available for %s", pid)
            return

        logger.info("Processing %s with operator %s", pid, op.name)
        # perform deterministic execution (no external calls)
        result = self._execute_task(ptype, json.loads(payload_json), op)
        # persist result and book revenue/payout atomically
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("BEGIN IMMEDIATE")
            cur.execute("UPDATE problems SET status = ?, result = ?, updated_at = ? WHERE id = ?",
                        (ProblemStatus.COMPLETED.value, json.dumps(result, ensure_ascii=False), int(time.time()), pid))
            # book revenue
            rid = str(uuid.uuid4())
            cur.execute("INSERT INTO revenues (id, problem_id, amount, currency, created_at) VALUES (?, ?, ?, ?, ?)",
                        (rid, pid, price, "EUR", int(time.time())))
            # compute operator fee and owner share
            operator_fee = round(price * 0.2 * op.factor, 2)
            owner_share = round(price - operator_fee, 2)
            payout_id = str(uuid.uuid4())
            cur.execute("INSERT INTO payouts (id, problem_id, amount, currency, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                        (payout_id, pid, owner_share, "EUR", PayoutStatus.EARNED.value, int(time.time()), int(time.time())))
            # mark queue entry as processed (delete)
            cur.execute("DELETE FROM work_queue WHERE problem_id = ?", (pid,))
            conn.commit()
            logger.info("Problem %s completed. Revenue %s, Payout %s owner_share=%.2f operator_fee=%.2f", pid, rid, payout_id, owner_share, operator_fee)
        except Exception:
            conn.rollback()
            logger.exception("Failed to persist completion for %s", pid)
        finally:
            conn.close()

    def _execute_task(self, ptype: str, payload: Dict[str, Any], operator: Operator) -> Dict[str, Any]:
        # deterministic, production-like execution logic
        if ptype == "text_analysis":
            text = str(payload.get("text", ""))
            # compute metrics
            words = text.split()
            chars = len(text)
            words_count = len(words)
            # operator-influenced processing time (non-blocking minimal)
            time.sleep(min(1.5, 0.05 + (chars / 2000.0) * operator.factor))
            return {"type": "text_analysis", "chars": chars, "words": words_count, "preview": text[:200], "operator": operator.name}
        elif ptype == "numeric_analysis":
            nums = payload.get("numbers", [])
            nums = [float(x) for x in nums]
            time.sleep(min(1.0, 0.02 + (len(nums) * 0.005) * operator.factor))
            if not nums:
                return {"type": "numeric_analysis", "count": 0, "operator": operator.name}
            return {"type": "numeric_analysis", "count": len(nums), "sum": sum(nums), "min": min(nums), "max": max(nums), "avg": sum(nums) / len(nums), "operator": operator.name}
        else:
            time.sleep(0.1)
            return {"type": "noop", "payload": payload, "operator": operator.name}

    # -------------------------
    # Meta-Auto-Repair: finalize payouts into pool
    # -------------------------
    def meta_auto_repair(self) -> Dict[str, Any]:
        conn = sqlite3.connect(self.db_path)
        repaired = 0
        try:
            cur = conn.cursor()
            cur.execute("BEGIN IMMEDIATE")
            # move EARNED -> READY
            cur.execute("UPDATE payouts SET status = ? WHERE status = ?", (PayoutStatus.READY.value, PayoutStatus.EARNED.value))
            # finalize READY -> DONE and add to pool
            cur.execute("SELECT id, amount FROM payouts WHERE status = ?", (PayoutStatus.READY.value,))
            rows = cur.fetchall()
            for pid, amount in rows:
                cur.execute("UPDATE payouts SET status = ?, updated_at = ? WHERE id = ?", (PayoutStatus.DONE.value, int(time.time()), pid))
                # add to pool
                cur.execute("UPDATE owner_pool SET balance = balance + ?, updated_at = ? WHERE id = 1", (amount, int(time.time())))
                repaired += 1
            conn.commit()
            logger.info("Meta-Auto-Repair finalized %d payouts", repaired)
            return {"repaired": repaired, "pool_balance": self.get_pool_balance()}
        except Exception:
            conn.rollback()
            logger.exception("Meta-Auto-Repair failed")
            return {"repaired": repaired, "pool_balance": self.get_pool_balance()}
        finally:
            conn.close()

    def get_pool_balance(self) -> float:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT balance FROM owner_pool WHERE id = 1")
            row = cur.fetchone()
            return float(row[0]) if row else 0.0
        finally:
            conn.close()

    # -------------------------
    # Withdrawals
    # -------------------------
    def create_withdrawal(self, amount: float, method: str, note: str = "") -> Optional[str]:
        if amount <= 0:
            logger.error("Withdrawal amount must be positive")
            return None
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("BEGIN IMMEDIATE")
            cur.execute("SELECT balance FROM owner_pool WHERE id = 1")
            row = cur.fetchone()
            if not row or row[0] < amount:
                conn.rollback()
                logger.error("Insufficient pool balance for withdrawal")
                return None
            new_balance = row[0] - amount
            cur.execute("UPDATE owner_pool SET balance = ?, updated_at = ? WHERE id = 1", (new_balance, int(time.time())))
            wid = str(uuid.uuid4())
            cur.execute("INSERT INTO withdrawals (id, amount, currency, method, note, status, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                        (wid, amount, "EUR", method, note, WithdrawalStatus.COMPLETED.value, int(time.time()), int(time.time())))
            conn.commit()
            logger.info("Withdrawal %s completed amount=%.2f method=%s", wid, amount, method)
            return wid
        except Exception:
            conn.rollback()
            logger.exception("Withdrawal failed")
            return None
        finally:
            conn.close()

    # -------------------------
    # Introspection & Utilities
    # -------------------------
    def list_problems(self, limit: int = 100) -> List[Dict[str, Any]]:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT id, type, payload, status, price, result, error, created_at, updated_at FROM problems ORDER BY created_at DESC LIMIT ?", (limit,))
            rows = cur.fetchall()
            out = []
            for r in rows:
                out.append({
                    "id": r[0], "type": r[1], "payload": json.loads(r[2]), "status": r[3], "price": r[4],
                    "result": json.loads(r[5]) if r[5] else None, "error": r[6], "created_at": r[7], "updated_at": r[8]
                })
            return out
        finally:
            conn.close()

    def list_payouts(self) -> List[Dict[str, Any]]:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT id, problem_id, amount, currency, status, created_at, updated_at FROM payouts ORDER BY created_at DESC")
            rows = cur.fetchall()
            return [{"id": r[0], "problem_id": r[1], "amount": r[2], "currency": r[3], "status": r[4], "created_at": r[5], "updated_at": r[6]} for r in rows]
        finally:
            conn.close()

    def revenue_summary(self) -> Dict[str, Any]:
        conn = sqlite3.connect(self.db_path)
        try:
            cur = conn.cursor()
            cur.execute("SELECT SUM(amount), COUNT(*) FROM revenues")
            row = cur.fetchone()
            total = float(row[0]) if row and row[0] is not None else 0.0
            count = int(row[1]) if row else 0
            return {"total_revenue": round(total, 2), "entries": count, "currency": "EUR"}
        finally:
            conn.close()

    def dump_state_keys(self) -> List[str]:
        return ["problems", "payment_intents", "revenues", "payouts", "owner_pool", "withdrawals", "operators"]

    # -------------------------
    # Shutdown
    # -------------------------
    def shutdown(self):
        logger.info("Shutdown initiated")
        self._stop_event.set()
        # wait for workers to finish current tasks
        for w in self.workers:
            w.join(timeout=2.0)
        logger.info("Workers stopped")

# -------------------------
# CLI Controller (minimal, no demo)
# -------------------------
def cli_loop(kernel: EngineKernel):
    print("Engine Kernel Theta - CLI (type 'help' for commands)")
    try:
        while True:
            cmd = input("> ").strip()
            if not cmd:
                continue
            parts = cmd.split()
            c = parts[0].lower()
            if c == "help":
                print("commands: help, status, submit, confirm, list, payouts, revenue, pool, withdraw, addop, ops, passwd, shutdown, exit")
            elif c == "status":
                print("workers:", len(kernel.workers), "db:", kernel.db_path)
                print("queue_pending:", len(kernel.list_pending_queue()))
            elif c == "submit":
                # usage: submit text_analysis Your text here...
                if len(parts) < 3:
                    print("usage: submit <type> <json-payload-or-raw-text>")
                    continue
                ptype = parts[1]
                raw = " ".join(parts[2:])
                payload = {}
                if ptype == "text_analysis":
                    payload = {"text": raw}
                elif ptype == "numeric_analysis":
                    try:
                        nums = json.loads(raw)
                        payload = {"numbers": nums}
                    except Exception:
                        print("numeric_analysis expects JSON array of numbers")
                        continue
                else:
                    payload = {"data": raw}
                pid = kernel.submit_problem(ptype, payload)
                print("submitted:", pid)
            elif c == "confirm":
                # confirm <intent_id>
                if len(parts) != 2:
                    print("usage: confirm <intent_id>")
                    continue
                intent_id = parts[1]
                ok = kernel.confirm_payment(intent_id)
                print("confirmed:", ok)
            elif c == "list":
                items = kernel.list_problems(20)
                for it in items:
                    print(it["id"], it["type"], it["status"], "price=", it["price"])
            elif c == "payouts":
                for p in kernel.list_payouts():
                    print(p)
            elif c == "revenue":
                print(kernel.revenue_summary())
            elif c == "pool":
                print("pool_balance:", kernel.get_pool_balance())
            elif c == "withdraw":
                # withdraw <amount> <method> [note]
                if len(parts) < 3:
                    print("usage: withdraw <amount> <method> [note]")
                    continue
                try:
                    amount = float(parts[1])
                except ValueError:
                    print("invalid amount")
                    continue
                method = parts[2]
                note = " ".join(parts[3:]) if len(parts) > 3 else ""
                wid = kernel.create_withdrawal(amount, method, note)
                print("withdrawal_id:", wid)
            elif c == "addop":
                # addop <name> <cap1,cap2> <factor>
                if len(parts) < 4:
                    print("usage: addop <name> <cap1,cap2> <factor>")
                    continue
                name = parts[1]
                caps = parts[2].split(",")
                try:
                    factor = float(parts[3])
                except ValueError:
                    factor = 1.0
                op = kernel.add_operator(name, caps, factor)
                print("operator added:", op.id)
            elif c == "ops":
                for op in kernel.list_operators():
                    print(asdict(op))
            elif c == "passwd":
                # passwd <username> <old> <new>
                if len(parts) != 4:
                    print("usage: passwd <username> <old> <new>")
                    continue
                ok = kernel.admin_change_password(parts[1], parts[2], parts[3])
                print("password changed:", ok)
            elif c in ("shutdown", "exit", "quit"):
                print("shutting down kernel...")
                kernel.shutdown()
                break
            else:
                print("unknown command:", c)
    except (KeyboardInterrupt, EOFError):
        print("\nshutting down kernel...")
        kernel.shutdown()

# -------------------------
# Entrypoint
# -------------------------
if __name__ == "__main__":
    # Start kernel in autonomous, real mode. No demo, no simulation placeholders.
    kernel = EngineKernel(worker_count=2)
    # Ensure at least one operator exists
    if not kernel.list_operators():
        kernel.add_operator("theta-core-1", ["text_analysis", "numeric_analysis"], factor=1.0)
    logger.info("Engine Kernel Theta is ACTIVE and running in autonomous kernel mode.")
    # Enter CLI loop for direct control (no demo automation)
    cli_loop(kernel)
