"""
OperatorTheta RuleCore + PayToSolve Engine
-----------------------------------------

VOLLSTÄNDIGES, EIN-FILE PYTHON-SYSTEM:

- Regelbasierte Engine:
    Problems -> WorkLines -> WorkJobs -> Revenue-Estimate
- Pay-to-Solve-Logik:
    Kein Job läuft, bevor eine Zahlung (on-chain oder manuell) bestätigt ist.
- Wallet:
    Ziel-Adresse (Ethereum-kompatibel):
        0xaD9C4d911dEa2086D7b3288E5fC36ADDb372FA3c
- Payment-Domain:
    PaymentRecords, die zu Problem/Job gehören
- Dashboard:
    /dashboard mit Live-Übersicht (Problems, Jobs, Revenue, Payments)
- API:
    FastAPI-Endpunkte für Problems, WorkLines, Jobs, Artifacts, Metrics, Payments, Events/SSE
- Optionaler Payment-Watcher:
    Skeleton zum Polling externer Block-Explorer-APIs (z.B. Etherscan),
    um eingehende Zahlungen auf die Wallet zu erkennen und Payments zu bestätigen.

ANLEITUNG (COPY-PASTE READY):

1. Projekt & Umgebung:

    python -m venv venv
    source venv/bin/activate          # Windows: venv\\Scripts\\activate

2. Pakete installieren:

    pip install fastapi uvicorn[standard] jinja2 httpx

   (httpx nur nötig, wenn du später den Payment-Watcher aktiv verwendest.)

3. Datei speichern als:

    theta_rulecore_pay.py

4. Server starten:

    python theta_rulecore_pay.py

5. Browser öffnen:

    - Dashboard:         http://127.0.0.1:8000/dashboard
    - API-Dokumentation: http://127.0.0.1:8000/docs

6. Pay-to-Solve-Fluss (manuell):

    a) Problem anlegen (POST /problems)
    b) PaymentIntent anlegen (POST /payments/intent)
    c) Zahlung extern an die Wallet senden (z.B. mit MetaMask)
    d) Payment manuell bestätigen (POST /payments/confirm) ODER
       Payment-Watcher so erweitern, dass er on-chain Events abfragt und /payments/confirm aufruft.
    e) Sobald Payment bestätigt, erstellt der Worker automatisch WorkJob, berechnet Revenue und erzeugt Artefakte.


WICHTIG:
- Diese Engine führt KEINE echten Transaktionen aus.
- Sie modelliert einen Pay-to-Solve-Workflow und kann an echte Payment-Provider / On-Chain-Listener angebunden werden.
"""

from __future__ import annotations

import asyncio
import math
import time
import uuid
from dataclasses import dataclass, field, asdict
from enum import Enum
from typing import List, Dict, Optional, Any

import httpx
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, HTMLResponse
from pydantic import BaseModel, Field


# =============================================================================
# KONFIGURATION
# =============================================================================

TARGET_WALLET_ADDRESS = "0xaD9C4d911dEa2086D7b3288E5fC36ADDb372FA3c"
PAYMENT_CURRENCY = "ETH"  # symbolische Anzeige

# Optional: Etherscan-ähnliche API-Details (nur Skeleton)
ETHERSCAN_API_KEY = "YOUR_ETHERSCAN_API_KEY_HERE"  # Platzhalter
ETHERSCAN_BASE_URL = "https://api.etherscan.io/api"  # Nur Beispiel


# =============================================================================
# ENUMS / STATI
# =============================================================================

class Severity(str, Enum):
    moderate = "moderate"
    high = "high"
    critical = "critical"


class ProblemStatus(str, Enum):
    open = "open"
    awaiting_payment = "awaiting_payment"
    analyzing = "analyzing"
    solved = "solved"
    failed = "failed"


class JobStatus(str, Enum):
    queued = "queued"
    running = "running"
    completed = "completed"
    failed = "failed"


class PaymentStatus(str, Enum):
    intent_created = "intent_created"     # PaymentIntent existiert, noch kein Eingang
    pending_onchain = "pending_onchain"   # Zahlung evtl. unterwegs
    confirmed = "confirmed"               # Zahlung bestätigt
    cancelled = "cancelled"               # abgebrochen


# =============================================================================
# DOMAIN-MODELLE
# =============================================================================

@dataclass
class Problem:
    id: str
    title: str
    description: str
    severity: Severity
    tags: List[str]
    created_at: float
    updated_at: float
    status: ProblemStatus = ProblemStatus.open
    meta: Dict[str, Any] = field(default_factory=dict)


@dataclass
class WorkLine:
    id: str
    name: str
    description: str
    base_value_eur: float
    complexity_factor: float
    allowed_tags: List[str]
    created_at: float
    active: bool = True


@dataclass
class WorkJob:
    id: str
    problem_id: str
    workline_id: str
    created_at: float
    updated_at: float
    status: JobStatus
    priority: float
    complexity_score: float
    difficulty_index: float
    solution_confidence: float
    revenue_estimate_eur: float
    phases: List[str]
    logs: List[str] = field(default_factory=list)
    result_summary: Optional[str] = None
    result_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class SolutionArtifact:
    id: str
    problem_id: str
    job_id: str
    kind: str
    created_at: float
    payload: Dict[str, Any]


@dataclass
class EngineMetric:
    timestamp: float
    total_problems: int
    total_jobs: int
    solved_problems: int
    failed_problems: int
    completed_jobs: int
    failed_jobs: int
    total_revenue_estimate: float
    confirmed_revenue_estimate: float


@dataclass
class PaymentRecord:
    id: str
    problem_id: str
    job_id: Optional[str]
    wallet_address: str
    expected_amount: float
    currency: str
    status: PaymentStatus
    created_at: float
    updated_at: float
    tx_hash: Optional[str] = None
    meta: Dict[str, Any] = field(default_factory=dict)


# =============================================================================
# API-SCHEMAS
# =============================================================================

class ProblemCreate(BaseModel):
    title: str
    description: str
    severity: Severity = Severity.critical
    tags: List[str] = Field(default_factory=list)
    meta: Dict[str, Any] = Field(default_factory=dict)


class ProblemView(BaseModel):
    id: str
    title: str
    description: str
    severity: Severity
    tags: List[str]
    created_at: float
    updated_at: float
    status: ProblemStatus
    meta: Dict[str, Any]


class WorkLineView(BaseModel):
    id: str
    name: str
    description: str
    base_value_eur: float
    complexity_factor: float
    allowed_tags: List[str]
    created_at: float
    active: bool


class JobView(BaseModel):
    id: str
    problem_id: str
    workline_id: str
    created_at: float
    updated_at: float
    status: JobStatus
    priority: float
    complexity_score: float
    difficulty_index: float
    solution_confidence: float
    revenue_estimate_eur: float
    phases: List[str]
    logs: List[str]
    result_summary: Optional[str]
    result_data: Dict[str, Any]


class SolutionArtifactView(BaseModel):
    id: str
    problem_id: str
    job_id: str
    kind: str
    created_at: float
    payload: Dict[str, Any]


class EngineMetricView(BaseModel):
    timestamp: float
    total_problems: int
    total_jobs: int
    solved_problems: int
    failed_problems: int
    completed_jobs: int
    failed_jobs: int
    total_revenue_estimate: float
    confirmed_revenue_estimate: float


class PaymentIntentCreate(BaseModel):
    problem_id: str
    expected_amount: float
    currency: str = PAYMENT_CURRENCY
    meta: Dict[str, Any] = Field(default_factory=dict)


class PaymentView(BaseModel):
    id: str
    problem_id: str
    job_id: Optional[str]
    wallet_address: str
    expected_amount: float
    currency: str
    status: PaymentStatus
    created_at: float
    updated_at: float
    tx_hash: Optional[str]
    meta: Dict[str, Any]


class PaymentConfirmRequest(BaseModel):
    payment_id: str
    tx_hash: Optional[str] = None
    meta: Dict[str, Any] = Field(default_factory=dict)


# =============================================================================
# STORE
# =============================================================================

class RuleCoreStore:
    def __init__(self) -> None:
        self.problems: Dict[str, Problem] = {}
        self.worklines: Dict[str, WorkLine] = {}
        self.jobs: Dict[str, WorkJob] = {}
        self.artifacts: Dict[str, SolutionArtifact] = {}
        self.metrics: List[EngineMetric] = {}
        self.payments: Dict[str, PaymentRecord] = {}
        self._lock = asyncio.Lock()

    # Problems
    async def add_problem(self, p: Problem) -> None:
        async with self._lock:
            self.problems[p.id] = p

    async def update_problem(self, p: Problem) -> None:
        async with self._lock:
            self.problems[p.id] = p

    async def get_problem(self, pid: str) -> Optional[Problem]:
        async with self._lock:
            return self.problems.get(pid)

    async def list_problems(self) -> List[Problem]:
        async with self._lock:
            return list(self.problems.values())

    # WorkLines
    async def add_workline(self, w: WorkLine) -> None:
        async with self._lock:
            self.worklines[w.id] = w

    async def list_worklines(self) -> List[WorkLine]:
        async with self._lock:
            return list(self.worklines.values())

    async def get_workline(self, wid: str) -> Optional[WorkLine]:
        async with self._lock:
            return self.worklines.get(wid)

    # Jobs
    async def add_job(self, j: WorkJob) -> None:
        async with self._lock:
            self.jobs[j.id] = j

    async def update_job(self, j: WorkJob) -> None:
        async with self._lock:
            self.jobs[j.id] = j

    async def get_job(self, jid: str) -> Optional[WorkJob]:
        async with self._lock:
            return self.jobs.get(jid)

    async def list_jobs(self, problem_id: Optional[str] = None) -> List[WorkJob]:
        async with self._lock:
            if problem_id:
                return [j for j in self.jobs.values() if j.problem_id == problem_id]
            return list(self.jobs.values())

    # Artefakte
    async def add_artifact(self, a: SolutionArtifact) -> None:
        async with self._lock:
            self.artifacts[a.id] = a

    async def list_artifacts_for_problem(self, pid: str) -> List[SolutionArtifact]:
        async with self._lock:
            return [a for a in self.artifacts.values() if a.problem_id == pid]

    # Payments
    async def add_payment(self, pay: PaymentRecord) -> None:
        async with self._lock:
            self.payments[pay.id] = pay

    async def update_payment(self, pay: PaymentRecord) -> None:
        async with self._lock:
            self.payments[pay.id] = pay

    async def get_payment(self, pid: str) -> Optional[PaymentRecord]:
        async with self._lock:
            return self.payments.get(pid)

    async def list_payments(self, problem_id: Optional[str] = None) -> List[PaymentRecord]:
        async with self._lock:
            if problem_id:
                return [p for p in self.payments.values() if p.problem_id == problem_id]
            return list(self.payments.values())

    async def list_confirmed_payments_for_problem(self, problem_id: str) -> List[PaymentRecord]:
        async with self._lock:
            return [
                p for p in self.payments.values()
                if p.problem_id == problem_id and p.status == PaymentStatus.confirmed
            ]

    # Metrics
    async def snapshot_metrics(self) -> EngineMetric:
        async with self._lock:
            total_problems = len(self.problems)
            total_jobs = len(self.jobs)
            solved_problems = len([p for p in self.problems.values() if p.status == ProblemStatus.solved])
            failed_problems = len([p for p in self.problems.values() if p.status == ProblemStatus.failed])
            completed_jobs = len([j for j in self.jobs.values() if j.status == JobStatus.completed])
            failed_jobs = len([j for j in self.jobs.values() if j.status == JobStatus.failed])
            total_revenue_estimate = sum(j.revenue_estimate_eur for j in self.jobs.values())
            confirmed_payments = [p for p in self.payments.values() if p.status == PaymentStatus.confirmed]
            # hier könntest du echte On-Chain-Beträge hinterlegen; aktuell: expected_amount
            confirmed_revenue_estimate = sum(p.expected_amount for p in confirmed_payments)

        metric = EngineMetric(
            timestamp=time.time(),
            total_problems=total_problems,
            total_jobs=total_jobs,
            solved_problems=solved_problems,
            failed_problems=failed_problems,
            completed_jobs=completed_jobs,
            failed_jobs=failed_jobs,
            total_revenue_estimate=round(total_revenue_estimate, 2),
            confirmed_revenue_estimate=round(confirmed_revenue_estimate, 6),
        )
        async with self._lock:
            self.metrics.append(metric)
        return metric


store = RuleCoreStore()


# =============================================================================
# EVENT-BUS (SSE)
# =============================================================================

class EventBus:
    def __init__(self) -> None:
        self.subscribers: List[asyncio.Queue] = []

    async def subscribe(self) -> asyncio.Queue:
        q: asyncio.Queue = asyncio.Queue()
        self.subscribers.append(q)
        return q

    async def unsubscribe(self, q: asyncio.Queue) -> None:
        if q in self.subscribers:
            self.subscribers.remove(q)

    async def publish(self, event_type: str, payload: Dict[str, Any]) -> None:
        event = {
            "type": event_type,
            "timestamp": time.time(),
            "payload": payload,
        }
        for q in self.subscribers:
            await q.put(event)


bus = EventBus()


# =============================================================================
# FORMEL- UND REGEL-LOGIK
# =============================================================================

def severity_weight(severity: Severity) -> float:
    return {
        Severity.critical: 1.0,
        Severity.high: 0.7,
        Severity.moderate: 0.4,
    }[severity]


def tag_complexity(tags: List[str]) -> float:
    base = len(tags)
    bonus = 0.0
    special = {"distributed", "nonlinear", "stochastic", "quantum", "np-hard", "chaos"}
    for t in tags:
        tl = t.lower()
        if tl in special:
            bonus += 2.0
        elif len(tl) > 10:
            bonus += 0.5
    return base + bonus


def compute_priority(severity: Severity, complexity: float) -> float:
    w = severity_weight(severity)
    return 100.0 * w * (1.0 + math.log(1.0 + complexity))


def estimate_solution_confidence(severity: Severity, complexity: float) -> float:
    w = severity_weight(severity)
    base_conf = 0.8 - 0.1 * w
    damping = 1.0 / (1.0 + 0.3 * complexity)
    conf = base_conf * damping
    return max(0.05, min(0.95, conf))


def difficulty_index(severity: Severity, complexity: float) -> float:
    return severity_weight(severity) * (1.0 + math.log(1.0 + complexity))


def estimate_revenue(workline: WorkLine, difficulty: float) -> float:
    factor = 1.0 + workline.complexity_factor * difficulty
    return round(workline.base_value_eur * factor, 2)


def extract_phases(problem: Problem, workline: WorkLine) -> List[str]:
    phases = [
        "normalize_problem",
        "extract_constraints",
        "map_to_workline",
        "design_solution_path",
        "prepare_science_artifacts",
    ]
    lower_tags = [t.lower() for t in problem.tags]

    if any(x in lower_tags for x in ["infra", "scaling", "distributed"]):
        phases.append("capacity_and_bottleneck_analysis")
    if any(x in lower_tags for x in ["ai", "ml", "nn"]):
        phases.append("model_and_data_analysis")
    if any(x in lower_tags for x in ["quantum", "math", "physics"]):
        phases.append("formal_modeling")

    phases.append(f"workline_specific: {workline.name}")
    return phases


def select_workline(problem: Problem, worklines: List[WorkLine]) -> Optional[WorkLine]:
    best: Optional[WorkLine] = None
    best_score = -1.0
    problem_tags = {t.lower() for t in problem.tags}

    for w in worklines:
        if not w.active:
            continue
        overlap = problem_tags.intersection({t.lower() for t in w.allowed_tags})
        overlap_score = len(overlap) * 10.0
        sev_bonus = severity_weight(problem.severity) * 5.0
        value_score = math.log(1.0 + w.base_value_eur)
        score = overlap_score + sev_bonus + value_score
        if score > best_score:
            best_score = score
            best = w

    return best


def synthesize_result(problem: Problem, job: WorkJob, workline: WorkLine) -> tuple[str, Dict[str, Any]]:
    summary_lines = [
        f"Problem: {problem.title}",
        f"Severity: {problem.severity.value}",
        f"Tags: {', '.join(problem.tags) if problem.tags else '-'}",
        f"WorkLine: {workline.name}",
        "",
        "Formelbasierte Kennzahlen:",
        f"  - Komplexität: {job.complexity_score:.3f}",
        f"  - Schwierigkeitsindex: {job.difficulty_index:.3f}",
        f"  - Anfangs-Confidence: {job.solution_confidence:.3f}",
        f"  - Revenue-Schätzung (EUR): {job.revenue_estimate_eur:.2f}",
        "",
        "Phasen:",
    ]
    summary_lines.extend([f"  - {p}" for p in job.phases])
    summary_lines += [
        "",
        "Interpretation:",
        "  Diese Engine bildet die Meta-Sicht ab. An dieser Stelle kannst du",
        "  konkrete wissenschaftliche/technische Modelle (Simulationen, Optimizer etc.) einhängen.",
    ]
    summary = "\n".join(summary_lines)

    data = {
        "problem_id": problem.id,
        "job_id": job.id,
        "workline_id": workline.id,
        "complexity_score": job.complexity_score,
        "difficulty_index": job.difficulty_index,
        "solution_confidence": job.solution_confidence,
        "revenue_estimate_eur": job.revenue_estimate_eur,
        "phases": job.phases,
    }
    return summary, data


def build_artifacts(problem: Problem, job: WorkJob, workline: WorkLine) -> List[SolutionArtifact]:
    now = time.time()
    artifacts: List[SolutionArtifact] = []

    spec_payload = {
        "title": f"{workline.name} – Spec für: {problem.title}",
        "sections": [
            "1. Problem Statement",
            "2. Kontext & Rahmenbedingungen",
            "3. Formale Modellierung / Architektur",
            "4. Experiment-/Simulationssetup",
            "5. Auswertung & Erfolgskriterien",
        ],
        "tags": problem.tags,
        "workline": workline.name,
    }
    artifacts.append(
        SolutionArtifact(
            id=str(uuid.uuid4()),
            problem_id=problem.id,
            job_id=job.id,
            kind="spec_outline",
            created_at=now,
            payload=spec_payload,
        )
    )

    experiment_payload = {
        "notebook_hint": f"notebooks/{problem.id}_{workline.id}.ipynb",
        "steps": [
            "Daten/Parameter definieren",
            "Modelle/Gleichungen implementieren",
            "Parameter-Sweeps / Szenarien laufen lassen",
            "Metriken sammeln",
            "Ergebnisse interpretieren",
        ],
    }
    artifacts.append(
        SolutionArtifact(
            id=str(uuid.uuid4()),
            problem_id=problem.id,
            job_id=job.id,
            kind="experiment_plan",
            created_at=now,
            payload=experiment_payload,
        )
    )

    return artifacts


# =============================================================================
# WORKER LOOP (Pay-to-Solve-Regel integriert)
# =============================================================================

async def worker_loop():
    while True:
        await asyncio.sleep(0.5)

        problems = await store.list_problems()
        worklines = await store.list_worklines()

        # Nur Probleme, für die es mindestens eine bestätigte Zahlung gibt:
        paid_problems: List[Problem] = []
        for p in problems:
            confirmed = await store.list_confirmed_payments_for_problem(p.id)
            if confirmed:
                paid_problems.append(p)

        for p in paid_problems:
            if p.status == ProblemStatus.open or p.status == ProblemStatus.awaiting_payment:
                p.status = ProblemStatus.analyzing
                p.updated_at = time.time()
                await store.update_problem(p)

            jobs = await store.list_jobs(problem_id=p.id)
            unfinished = [j for j in jobs if j.status in (JobStatus.queued, JobStatus.running)]

            if not unfinished:
                wl = select_workline(p, worklines)
                if wl is None:
                    continue

                comp = tag_complexity(p.tags)
                prio = compute_priority(p.severity, comp)
                diff = difficulty_index(p.severity, comp)
                conf = estimate_solution_confidence(p.severity, comp)
                rev = estimate_revenue(wl, diff)
                phases = extract_phases(p, wl)

                now = time.time()
                job = WorkJob(
                    id=str(uuid.uuid4()),
                    problem_id=p.id,
                    workline_id=wl.id,
                    created_at=now,
                    updated_at=now,
                    status=JobStatus.queued,
                    priority=prio,
                    complexity_score=comp,
                    difficulty_index=diff,
                    solution_confidence=conf,
                    revenue_estimate_eur=rev,
                    phases=phases,
                    logs=[f"Job created (prio={prio:.2f}, diff={diff:.2f}, rev={rev:.2f})"],
                )
                await store.add_job(job)
                await bus.publish("job_created", {"job_id": job.id, "problem_id": p.id})

            jobs = await store.list_jobs(problem_id=p.id)
            for j in jobs:
                wl = await store.get_workline(j.workline_id)
                if wl is None:
                    continue

                if j.status == JobStatus.queued:
                    j.status = JobStatus.running
                    j.logs.append("Job started: running rule/formula pipeline.")
                    j.updated_at = time.time()
                    await store.update_job(j)
                    await bus.publish("job_started", {"job_id": j.id, "problem_id": p.id})

                elif j.status == JobStatus.running:
                    if time.time() - j.created_at > 2.0:
                        problem = await store.get_problem(j.problem_id)
                        if not problem:
                            continue

                        summary, data = synthesize_result(problem, j, wl)
                        j.status = JobStatus.completed
                        j.result_summary = summary
                        j.result_data = data
                        j.logs.append("Job completed: solution + revenue estimate generated.")
                        j.updated_at = time.time()
                        await store.update_job(j)

                        problem.status = ProblemStatus.solved
                        problem.updated_at = time.time()
                        await store.update_problem(problem)

                        artifacts = build_artifacts(problem, j, wl)
                        for a in artifacts:
                            await store.add_artifact(a)

                        await bus.publish(
                            "job_completed",
                            {
                                "job_id": j.id,
                                "problem_id": problem.id,
                                "revenue_estimate_eur": j.revenue_estimate_eur,
                            },
                        )

        metric = await store.snapshot_metrics()
        await bus.publish("metric_snapshot", asdict(metric))


# =============================================================================
# OPTIONAL: PAYMENT-WATCHER (SKELETON)
# =============================================================================

async def payment_watcher_loop():
    """
    Skeleton: Polling eines Block-Explorer-APIs, um eingehende Zahlungen auf TARGET_WALLET_ADDRESS zu erkennen.
    - Hier keinen realen Abruf implementiert, sondern Struktur für Erweiterung.
    - Für echten Einsatz:
        * HTTP-Anfragen an z.B. Etherscan
        * Filter auf TARGET_WALLET_ADDRESS
        * Zuordnung zu PaymentRecords anhand expected_amount oder meta
        * Aufruf von store.update_payment(...) + Status=confirmed
    """
    while False:
        # Standardmäßig deaktiviert (while False).
        # Setze auf True und implementiere deine echte On-Chain-Logik.
        await asyncio.sleep(10)
        # Beispiel-Pseudocode:
        #   async with httpx.AsyncClient() as client:
        #       res = await client.get(ETHERSCAN_BASE_URL, params={...})
        #   -> parse, match payments, update store
        pass


# =============================================================================
# FASTAPI & DASHBOARD
# =============================================================================

from fastapi.templating import Jinja2Templates

app = FastAPI(
    title="OperatorTheta RuleCore PayToSolve Engine",
    description="Regelbasierter Meta-Kern mit Pay-to-Solve Workflow und Einnahmen-Schätzung.",
    version="1.0.0",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

templates = Jinja2Templates(directory=".")


@app.on_event("startup")
async def on_startup():
    now = time.time()
    wl1 = WorkLine(
        id=str(uuid.uuid4()),
        name="ScienceLab Deep Analysis",
        description="Tiefe wissenschaftlich-technische Analyse mit Experiment-Planung.",
        base_value_eur=800.0,
        complexity_factor=0.8,
        allowed_tags=["science", "physics", "math", "nonlinear", "quantum"],
        created_at=now,
    )
    wl2 = WorkLine(
        id=str(uuid.uuid4()),
        name="System Architecture Fix",
        description="Gezielte Architektur- und Skalierungs-Fixes.",
        base_value_eur=1200.0,
        complexity_factor=0.6,
        allowed_tags=["infra", "scaling", "distributed", "architecture"],
        created_at=now,
    )
    wl3 = WorkLine(
        id=str(uuid.uuid4()),
        name="AI/ML Model Strategy",
        description="Meta-Strategie und Systematik für ML-/Modell-Setups.",
        base_value_eur=1500.0,
        complexity_factor=0.9,
        allowed_tags=["ai", "ml", "nn", "model"],
        created_at=now,
    )
    await store.add_workline(wl1)
    await store.add_workline(wl2)
    await store.add_workline(wl3)

    asyncio.create_task(worker_loop())
    # Payment-Watcher optional:
    # asyncio.create_task(payment_watcher_loop())


@app.get("/")
async def root():
    return {
        "name": "OperatorTheta RuleCore PayToSolve Engine",
        "status": "ok",
        "docs": "/docs",
        "wallet": TARGET_WALLET_ADDRESS,
    }


DASHBOARD_HTML = """
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>OperatorTheta RuleCore PayToSolve Dashboard</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; background: #0b1020; color: #f2f4ff; }
    h1, h2 { color: #f0f4ff; }
    .cards { display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 20px; }
    .card { background: #141a33; padding: 12px 16px; border-radius: 8px; min-width: 200px; }
    .label { font-size: 12px; color: #a3accf; text-transform: uppercase; letter-spacing: 0.06em; }
    .value { font-size: 20px; font-weight: 600; margin-top: 4px; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { padding: 8px 6px; border-bottom: 1px solid #262c44; font-size: 13px; }
    th { text-align: left; color: #a3accf; }
    tr:hover { background: #171f3a; }
    .tag { display: inline-block; padding: 2px 6px; border-radius: 4px; background: #202746; margin-right: 4px; font-size: 11px; }
    .status { font-size: 12px; padding: 2px 6px; border-radius: 4px; }
    .status-open { background: #3b3f6a; }
    .status-awaiting { background: #e67700; }
    .status-analyzing { background: #845ef7; }
    .status-solved { background: #2f9e44; }
    .status-failed { background: #c92a2a; }
    .status-job-queued { background: #3b3f6a; }
    .status-job-running { background: #e67700; }
    .status-job-completed { background: #2f9e44; }
    .status-job-failed { background: #c92a2a; }
    small { color: #8d95c2; }
    .layout { display: grid; grid-template-columns: 1.3fr 1fr; gap: 20px; }
    @media (max-width: 900px) { .layout { grid-template-columns: 1fr; } }
    code { background: #202746; padding: 2px 4px; border-radius: 4px; }
  </style>
</head>
<body>
  <h1>OperatorTheta RuleCore PayToSolve</h1>
  <p><small>Wallet für Eingänge (symbolisch): <code id="wallet-address"></code></small></p>

  <div class="cards" id="metrics-cards">
    <div class="card">
      <div class="label">Total Revenue (Jobs)</div>
      <div class="value" id="metric-revenue">-</div>
    </div>
    <div class="card">
      <div class="label">Confirmed Revenue (Payments)</div>
      <div class="value" id="metric-revenue-confirmed">-</div>
    </div>
    <div class="card">
      <div class="label">Problems</div>
      <div class="value" id="metric-problems">-</div>
    </div>
    <div class="card">
      <div class="label">Jobs</div>
      <div class="value" id="metric-jobs">-</div>
    </div>
  </div>

  <div class="layout">
    <div>
      <h2>Probleme</h2>
      <table id="problems-table">
        <thead>
          <tr>
            <th>Title</th>
            <th>Severity</th>
            <th>Status</th>
            <th>Tags</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div>
      <h2>WorkJobs & Payments</h2>
      <table id="jobs-table">
        <thead>
          <tr>
            <th>Job</th>
            <th>Problem</th>
            <th>Status</th>
            <th>Revenue est.</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>

      <h2 style="margin-top: 24px;">Payments</h2>
      <table id="payments-table">
        <thead>
          <tr>
            <th>Payment</th>
            <th>Problem</th>
            <th>Status</th>
            <th>Expected</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    async function fetchJSON(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status);
      return await res.json();
    }

    function statusClassForProblem(status) {
      if (status === "open") return "status status-open";
      if (status === "awaiting_payment") return "status status-awaiting";
      if (status === "analyzing") return "status status-analyzing";
      if (status === "solved") return "status status-solved";
      if (status === "failed") return "status status-failed";
      return "status";
    }

    function statusClassForJob(status) {
      if (status === "queued") return "status status-job-queued";
      if (status === "running") return "status status-job-running";
      if (status === "completed") return "status status-job-completed";
      if (status === "failed") return "status status-job-failed";
      return "status";
    }

    async function refreshAll() {
      try {
        const [root, metrics, problems, jobs, payments] = await Promise.all([
          fetchJSON("/"),
          fetchJSON("/metrics"),
          fetchJSON("/problems"),
          fetchJSON("/jobs"),
          fetchJSON("/payments"),
        ]);

        document.getElementById("wallet-address").textContent = root.wallet;

        document.getElementById("metric-revenue").textContent =
          metrics.total_revenue_estimate.toFixed(2) + " EUR";
        document.getElementById("metric-revenue-confirmed").textContent =
          metrics.confirmed_revenue_estimate.toFixed(6) + " " + "ETH";
        document.getElementById("metric-problems").textContent =
          metrics.total_problems;
        document.getElementById("metric-jobs").textContent =
          metrics.total_jobs;

        const pBody = document.querySelector("#problems-table tbody");
        pBody.innerHTML = "";
        problems.slice(-20).reverse().forEach(p => {
          const tr = document.createElement("tr");
          const tagsHtml = (p.tags || []).map(t => `<span class="tag">${t}</span>`).join(" ");
          tr.innerHTML = `
            <td>${p.title}</td>
            <td>${p.severity}</td>
            <td><span class="${statusClassForProblem(p.status)}">${p.status}</span></td>
            <td>${tagsHtml}</td>
          `;
          pBody.appendChild(tr);
        });

        const jBody = document.querySelector("#jobs-table tbody");
        jBody.innerHTML = "";
        jobs.slice(-20).reverse().forEach(j => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${j.id.slice(0, 6)}...</td>
            <td>${j.problem_id.slice(0, 6)}...</td>
            <td><span class="${statusClassForJob(j.status)}">${j.status}</span></td>
            <td>${j.revenue_estimate_eur.toFixed(2)} EUR</td>
          `;
          jBody.appendChild(tr);
        });

        const payBody = document.querySelector("#payments-table tbody");
        payBody.innerHTML = "";
        payments.slice(-20).reverse().forEach(p => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${p.id.slice(0, 6)}...</td>
            <td>${p.problem_id.slice(0, 6)}...</td>
            <td>${p.status}</td>
            <td>${p.expected_amount.toFixed(6)} ${p.currency}</td>
          `;
          payBody.appendChild(tr);
        });

      } catch (e) {
        console.error("Refresh error:", e);
      }
    }

    refreshAll();
    setInterval(refreshAll, 4000);

    try {
      const source = new EventSource("/events/stream");
      source.onmessage = _ => refreshAll();
    } catch (e) {
      console.warn("SSE nicht verfügbar:", e);
    }
  </script>
</body>
</html>
"""


@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard():
    return HTMLResponse(content=DASHBOARD_HTML)


# =============================================================================
# API: Problems, WorkLines, Jobs, Artifacts, Metrics
# =============================================================================

@app.post("/problems", response_model=ProblemView)
async def create_problem(req: ProblemCreate):
    now = time.time()
    p = Problem(
        id=str(uuid.uuid4()),
        title=req.title,
        description=req.description,
        severity=req.severity,
        tags=req.tags,
        created_at=now,
        updated_at=now,
        status=ProblemStatus.awaiting_payment,  # Pay-to-Solve: wartet auf PaymentIntent
        meta=req.meta,
    )
    await store.add_problem(p)
    await bus.publish("problem_created", {"problem_id": p.id})
    return ProblemView(**asdict(p))


@app.get("/problems", response_model=List[ProblemView])
async def list_problems():
    problems = await store.list_problems()
    return [ProblemView(**asdict(p)) for p in problems]


@app.get("/problems/{problem_id}", response_model=ProblemView)
async def get_problem(problem_id: str):
    p = await store.get_problem(problem_id)
    if not p:
        raise HTTPException(status_code=404, detail="Problem not found")
    return ProblemView(**asdict(p))


@app.get("/worklines", response_model=List[WorkLineView])
async def list_worklines():
    wls = await store.list_worklines()
    return [WorkLineView(**asdict(w)) for w in wls]


@app.get("/jobs", response_model=List[JobView])
async def list_jobs(problem_id: Optional[str] = None):
    jobs = await store.list_jobs(problem_id=problem_id)
    return [JobView(**asdict(j)) for j in jobs]


@app.get("/jobs/{job_id}", response_model=JobView)
async def get_job(job_id: str):
    j = await store.get_job(job_id)
    if not j:
        raise HTTPException(status_code=404, detail="Job not found")
    return JobView(**asdict(j))


@app.get("/artifacts/{problem_id}", response_model=List[SolutionArtifactView])
async def list_artifacts(problem_id: str):
    arts = await store.list_artifacts_for_problem(problem_id)
    return [SolutionArtifactView(**asdict(a)) for a in arts]


@app.get("/metrics", response_model=EngineMetricView)
async def get_metrics():
    metric = await store.snapshot_metrics()
    return EngineMetricView(**asdict(metric))


# =============================================================================
# API: PAYMENTS
# =============================================================================

@app.post("/payments/intent", response_model=PaymentView)
async def create_payment_intent(req: PaymentIntentCreate):
    problem = await store.get_problem(req.problem_id)
    if not problem:
        raise HTTPException(status_code=404, detail="Problem not found")

    now = time.time()
    pay = PaymentRecord(
        id=str(uuid.uuid4()),
        problem_id=req.problem_id,
        job_id=None,
        wallet_address=TARGET_WALLET_ADDRESS,
        expected_amount=req.expected_amount,
        currency=req.currency,
        status=PaymentStatus.intent_created,
        created_at=now,
        updated_at=now,
        meta=req.meta,
    )
    await store.add_payment(pay)

    # Problem bleibt auf awaiting_payment, bis Payment bestätigt
    await bus.publish("payment_intent_created", {"payment_id": pay.id, "problem_id": req.problem_id})
    return PaymentView(**asdict(pay))


@app.post("/payments/confirm", response_model=PaymentView)
async def confirm_payment(req: PaymentConfirmRequest):
    pay = await store.get_payment(req.payment_id)
    if not pay:
        raise HTTPException(status_code=404, detail="Payment not found")

    pay.status = PaymentStatus.confirmed
    pay.tx_hash = req.tx_hash
    pay.meta.update(req.meta)
    pay.updated_at = time.time()
    await store.update_payment(pay)

    problem = await store.get_problem(pay.problem_id)
    if problem:
        problem.status = ProblemStatus.analyzing
        problem.updated_at = time.time()
        await store.update_problem(problem)

    await bus.publish("payment_confirmed", {"payment_id": pay.id, "problem_id": pay.problem_id})
    return PaymentView(**asdict(pay))


@app.get("/payments", response_model=List[PaymentView])
async def list_payments(problem_id: Optional[str] = None):
    pays = await store.list_payments(problem_id=problem_id)
    return [PaymentView(**asdict(p)) for p in pays]


@app.get("/payments/{payment_id}", response_model=PaymentView)
async def get_payment(payment_id: str):
    pay = await store.get_payment(payment_id)
    if not pay:
        raise HTTPException(status_code=404, detail="Payment not found")
    return PaymentView(**asdict(pay))


# =============================================================================
# API: EVENTS / SSE
# =============================================================================

@app.get("/events/stream")
async def events_stream():
    async def event_generator():
        q = await bus.subscribe()
        try:
            while True:
                event = await q.get()
                yield f"data: {event}\n\n"
        finally:
            await bus.unsubscribe(q)

    return StreamingResponse(event_generator(), media_type="text/event-stream")


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "theta_rulecore_pay:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
    )
